From tony Mon Sep 17 00:00:00 2001
From: Tony Lindgren <tony@atomide.com>
Date: Tue, 22 Dec 2020 05:46:59 +0200
Subject: [PATCH] Enable pstore support for droid4

Enable pstore support that can be used to view kernel oopses in
/sys/fs/pstore after a watchdog reset, and can be also used for tracing.
This comes at the cost of the using 384KB of reserved-memory following
the configuration commonly used in the Linux kernel for pstore.

The reserved-memory is configured to overlap the area configured by the
Android kernel so we can have the bootloader preserve it. We don't need
to hog all the 2MB of the memory though that Android uses.

To make pstore work, we need to change the warm reset timings for the warm
reset to preserve DDR. Otherwise the DDR gets reset during the warm reset.
We also need to configure the PMIC.

To test pstore crash reporting, ssh to the device, and do the following
to crash the system:

# echo 1 > /proc/sys/kernel/sysrq
# echo c > /proc/sysrq-trigger

Wait for the system to reboot, and then ssh to the system again:

# ls /sys/fs/pstore
 ls /sys/fs/pstore/
console-ramoops-0  dmesg-ramoops-0

Note that the watchdog timeout should probably be configured to 20 seconds
to avoid having to wait a minute for system to reboot.

Signed-off-by: Tony Lindgren <tony@atomide.com>
---
 .../boot/dts/motorola-mapphone-common.dtsi    | 20 ++++++++
 arch/arm/configs/omap2plus_defconfig          |  5 ++
 arch/arm/mach-omap2/prm44xx.c                 | 11 +++++
 arch/arm/mach-omap2/prminst44xx.c             | 35 ++++++++++++++
 arch/arm/mach-omap2/prminst44xx.h             |  3 ++
 drivers/mfd/motorola-cpcap.c                  | 47 +++++++++++++++++++
 6 files changed, 121 insertions(+)

diff --git a/arch/arm/boot/dts/motorola-mapphone-common.dtsi b/arch/arm/boot/dts/motorola-mapphone-common.dtsi
--- a/arch/arm/boot/dts/motorola-mapphone-common.dtsi
+++ b/arch/arm/boot/dts/motorola-mapphone-common.dtsi
@@ -24,6 +24,26 @@ memory {
 		reg = <0x80000000 0x3fd00000>;	/* 1021 MB */
 	};
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/*
+		 * The stock kernel has 2M@0xa0000000 for ram_console using the
+		 * old file format. That won't work for us, so let's ignore the
+		 * first 512K of that and just overwrite the rest and configure
+		 * only 384K instead of 2M.
+		 */
+		ramoops@a0080000 {
+			compatible = "ramoops";
+			reg = <0xa0080000 0x60000>;
+			record-size = <0x20000>;
+			console-size = <0x20000>;
+			ftrace-size = <0x20000>;
+		};
+	};
+
 	/* Poweroff GPIO probably connected to CPCAP */
 	gpio-poweroff {
 		compatible = "gpio-poweroff";
diff --git a/arch/arm/configs/omap2plus_defconfig b/arch/arm/configs/omap2plus_defconfig
--- a/arch/arm/configs/omap2plus_defconfig
+++ b/arch/arm/configs/omap2plus_defconfig
@@ -567,6 +567,11 @@ CONFIG_JFFS2_LZO=y
 CONFIG_JFFS2_RUBIN=y
 CONFIG_UBIFS_FS=y
 CONFIG_CRAMFS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_FTRACE=y
+CONFIG_PSTORE_RAM=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
diff --git a/arch/arm/mach-omap2/prm44xx.c b/arch/arm/mach-omap2/prm44xx.c
--- a/arch/arm/mach-omap2/prm44xx.c
+++ b/arch/arm/mach-omap2/prm44xx.c
@@ -831,6 +831,17 @@ int __init omap44xx_prm_init(const struct omap_prcm_init_data *data)
 		cpu_pm_register_notifier(&nb);
 	}
 
+#ifdef CONFIG_PSTORE
+	/*
+	 * On droid4, the stock kernel configured reset times will clear
+	 * DDR on warm reset. Set the reset times to TRM defaults, the
+	 * stock kernel uses custom values of 16 and 200.
+	 */
+	if (of_machine_is_compatible("motorola,droid4") ||
+	    of_machine_is_compatible("motorola,bionic"))
+		omap4_prminst_global_reset_time(16, 6);
+#endif
+
 	return prm_register(&omap44xx_prm_ll_data);
 }
 
diff --git a/arch/arm/mach-omap2/prminst44xx.c b/arch/arm/mach-omap2/prminst44xx.c
--- a/arch/arm/mach-omap2/prminst44xx.c
+++ b/arch/arm/mach-omap2/prminst44xx.c
@@ -174,6 +174,41 @@ int omap4_prminst_deassert_hardreset(u8 shift, u8 st_shift, u8 part, s16 inst,
 	return (c == MAX_MODULE_HARDRESET_WAIT) ? -EBUSY : 0;
 }
 
+/**
+ * omap4_prminst_global_reset_time - configure hardwar reset register
+ * @pwrdm_cycles: power domain reset duration in clock cycles
+ * @reset_cycles: reset duration in clock cycles
+ *
+ * Configures the PRM_RSTTIME as documented in TRM. If no values are passed,
+ * Use the TRM default reset values instead.
+ */
+void omap4_prminst_global_reset_time(int pwrdm_cycles,
+				     int reset_cycles)
+{
+	s32 inst = omap4_prmst_get_prm_dev_inst();
+	u32 v = 0;
+
+	if (inst == PRM_INSTANCE_UNKNOWN)
+		return;
+
+	/* The smallest writable values are 1, use defaults if not specified */
+	if (pwrdm_cycles < 1)
+		v = 0x10 << 10;
+	else
+		v = (pwrdm_cycles & 0x1f) << 10;
+
+	if (reset_cycles < 1)
+		v |= 0x6;
+	else
+		v |= reset_cycles & 0x3ff;
+
+	omap4_prminst_write_inst_reg(v, OMAP4430_PRM_PARTITION,
+				     inst, OMAP4_PRM_RSTTIME_OFFSET);
+
+	/* OCP barrier */
+	v = omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,
+					inst, OMAP4_PRM_RSTTIME_OFFSET);
+}
 
 void omap4_prminst_global_warm_sw_reset(void)
 {
diff --git a/arch/arm/mach-omap2/prminst44xx.h b/arch/arm/mach-omap2/prminst44xx.h
--- a/arch/arm/mach-omap2/prminst44xx.h
+++ b/arch/arm/mach-omap2/prminst44xx.h
@@ -22,6 +22,9 @@ extern void omap4_prminst_write_inst_reg(u32 val, u8 part, s16 inst, u16 idx);
 extern u32 omap4_prminst_rmw_inst_reg_bits(u32 mask, u32 bits, u8 part,
 					   s16 inst, u16 idx);
 
+extern void omap4_prminst_global_reset_time(int pwrdm_cycles,
+					    int reset_cycles);
+
 extern void omap4_prminst_global_warm_sw_reset(void);
 
 extern int omap4_prminst_is_hardreset_asserted(u8 shift, u8 part, s16 inst,
diff --git a/drivers/mfd/motorola-cpcap.c b/drivers/mfd/motorola-cpcap.c
--- a/drivers/mfd/motorola-cpcap.c
+++ b/drivers/mfd/motorola-cpcap.c
@@ -24,6 +24,23 @@
 #define CPCAP_REGISTER_SIZE	4
 #define CPCAP_REGISTER_BITS	16
 
+/* Register CPCAP_REG_VAL1 bits */
+#define CPCAP_BIT_NVFLASH_MODE		BIT(14)
+#define CPCAP_BIT_RECOVERY_MODE		BIT(13)
+#define CPCAP_BIT_FASTBOOT_MODE		BIT(12)	/* Nope, not for fastboot */
+#define CPCAP_BIT_BOOT_MODE		BIT(11)	/* For fastboot mode */
+#define CPCAP_BIT_BP2_ONLY_FLASH	BIT(10)
+#define CPCAP_BIT_OUT_CHARGE_ONLY	BIT(9)
+#define CPCAP_BIT_USB_BATT_RECOVERY	BIT(8)
+#define CPCAP_BIT_PANIC			BIT(7)
+#define CPCAP_BIT_BP_ONLY_FLASH		BIT(6)
+#define CPCAP_BIT_WATCHDOG_RESET	BIT(5)
+#define CPCAP_BIT_SOFT_RESET		BIT(4)
+#define CPCAP_BIT_FLASH_FAIL		BIT(3)
+#define CPCAP_BIT_FOTA_MODE		BIT(2)
+#define CPCAP_BIT_AP_KERNEL_PANIC	BIT(1)
+#define CPCAP_BIT_FLASH_MODE		BIT(0)
+
 struct cpcap_ddata {
 	struct spi_device *spi;
 	struct regmap_irq *irqs;
@@ -85,6 +102,32 @@ static int cpcap_check_revision(struct cpcap_ddata *cpcap)
 	return 0;
 }
 
+static int cpcap_init_registers(struct cpcap_ddata *ddata)
+{
+	u16 val;
+	int err;
+
+	/* Stock kernel default values on power up */
+	val = CPCAP_BIT_OUT_CHARGE_ONLY | CPCAP_BIT_SOFT_RESET |
+		CPCAP_BIT_AP_KERNEL_PANIC;
+
+#ifdef CONFIG_PSTORE
+	/*
+	 * The CPCAP_BIT_PANIC seems to prevent the bootloader from clearing
+	 * the DDR memory. For pstore, also SoC PRM_RSTTIME needs to be set
+	 * to minimum values of 0x401.
+	 */
+	val |= CPCAP_BIT_PANIC;
+#endif
+
+	err = regmap_update_bits(ddata->regmap, CPCAP_REG_VAL1,
+				 0xffff, val);
+	if (err)
+		return err;
+
+	return 0;
+}
+
 /*
  * First two irq chips are the two private macro interrupt chips, the third
  * irq chip is for register banks 1 - 4 and is available for drivers to use.
@@ -323,6 +366,10 @@ static int cpcap_probe(struct spi_device *spi)
 		return ret;
 	}
 
+	ret = cpcap_init_registers(cpcap);
+	if (ret)
+		return ret;
+
 	ret = cpcap_init_irq(cpcap);
 	if (ret)
 		return ret;
-- 
2.29.2
